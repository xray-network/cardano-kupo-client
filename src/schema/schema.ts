export type paths = {
    "/matches": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get All Matches
         * @description Retrieve all matches from the database, in descending `slot_no` order. Results are streamed to the client for more efficiency.
         *
         *     Optionally, use `?resolve_hashes` to automatically resolve and include `datum` and `script` associated with hash references, if available. Datums and scripts can otherwise be fetched using the [_Get Datum by Hash_](#tag/Datums/paths/~1datums~1{datum_hash}/get) and [_Get Script by Hash_](#tag/Scripts/paths/~1scripts~1{script_hash}/get) endpoints respectively.
         *
         *     Note that it is generally a bad idea to fetch **ALL matches** for indexes built off permissive patterns (e.g. `*`), for the server will yield a large response.
         *
         */
        get: operations["getAllMatches"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/matches/{pattern}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Matches (*)
         * @description Retrieve matches from the database matching the given pattern, in descending `slot_no` order. Results are streamed to the client for more efficiency.
         *     See [Patterns](#section/Patterns) for more information about constructing patterns.
         *
         */
        get: operations["getMatches"];
        put?: never;
        post?: never;
        /**
         * Delete Matches (*)
         * @description Delete all matches matching the given pattern. Note that this operation is only allowed if the provided pattern isn't a currently active pattern.
         *
         */
        delete: operations["deleteMatches"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/datums/{datum_hash}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Datum by Hash
         * @description Retrieve the datum pre-image (i.e. full resolved datum) associated to a given datum hash digest.
         *
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description A datum blake2b-256 hash digest. */
                    datum_hash: components["parameters"]["datum-hash"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        "Content-Type"?: "application/json;charset=utf-8";
                        /** @description Kupo's most recent indexed block's slot number. This allows to know which slot a query is accurate of.
                         *      */
                        "X-Most-Recent-Checkpoint"?: number;
                        /** @description A cache value generated by the server to indicate whether a response has changed or not. The `ETag` always corresponds to the block header hash of the most recent indexed block.
                         *     This can be used in combination with [`If-None-Match`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#etagif-none-match) to provide some efficient client-side caching.
                         *      */
                        ETag?: string;
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json;charset=utf-8": components["schemas"]["Datum"] | null;
                    };
                };
                304: components["responses"]["304"];
                /** @description Bad Request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json;charset=utf-8": components["schemas"]["BadRequest"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/scripts/{script_hash}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Script by Hash
         * @description Retrieve the raw script (i.e. full resolved script) associated to a given script hash digest.
         *
         *     > <sup><strong>NOTE</strong></sup> <br/>
         *     >
         *     > Raw scripts aren't exact pre-image of their hash digest. Before hashing, scripts are prefixed with a
         *     > certain discriminator byte depending on the language. For instance, any native script is prefixed with
         *     > `00` before hashing.
         *     >
         *     > Here's a table summarizing all discriminators:
         *     >
         *     > | Language    | Discriminator Byte |
         *     > | ---         | ---                |
         *     > | `native`    | `00`               |
         *     > | `plutus:v1` | `01`               |
         *     > | `plutus:v2` | `02`               |
         *
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description A script blake2b-224 hash digest of a script. */
                    script_hash: components["parameters"]["script-hash"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        "Content-Type"?: "application/json;charset=utf-8";
                        /** @description Kupo's most recent indexed block's slot number. This allows to know which slot a query is accurate of.
                         *      */
                        "X-Most-Recent-Checkpoint"?: number;
                        /** @description A cache value generated by the server to indicate whether a response has changed or not. The `ETag` always corresponds to the block header hash of the most recent indexed block.
                         *     This can be used in combination with [`If-None-Match`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#etagif-none-match) to provide some efficient client-side caching.
                         *      */
                        ETag?: string;
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json;charset=utf-8": components["schemas"]["Script"] | null;
                    };
                };
                304: components["responses"]["304"];
                /** @description Bad Request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json;charset=utf-8": components["schemas"]["BadRequest"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/patterns": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Patterns
         * @description Retrieve all patterns currently configured on the server.
         *
         */
        get: operations["getPatterns"];
        /**
         * Bulk Add Patterns
         * @description Add many patterns at once. See [Add Pattern (*)](#operation/putPattern) for more details.
         *
         */
        put: operations["putPatterns"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/patterns/{pattern}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Pattern (*)
         * @description Retrieve all patterns that include<sup>*</sup> the provided pattern. Remember that an address is itself a pattern!
         *     This endpoint is thereby useful to check is an address is matched by a given pattern configuration (the returned
         *     list would be non-empty).
         *
         *     > <sup><strong>(*) Definition</strong></sup> <br/>
         *     > If all results matched by `y` are also matched by `x`, then `x` is said to include `y`.
         *
         */
        get: operations["matchPattern"];
        /**
         * Add Pattern (*)
         * @description Add a new pattern to watch and force the server to re-sync from a given point. Only blocks discovered from that point will be matched against the new pattern.
         *
         *     This endpoint may not be instantaneous as the forced rollback may only occur after the next block arrives in the indexer. On the main network, this takes usually
         *     no more than 20 seconds. On test networks however where the block density tends to be much lower, this may take longer.
         *
         *     Note also that, very long rollback will take a substantial amount of time to be processed by the server; if the server is shut down while a rollback is ongoing, the
         *     rollback will be aborted and the server will remain where it was, although with the extra pattern added.
         *
         */
        put: operations["putPattern"];
        post?: never;
        /**
         * Delete Pattern (*)
         * @description Removes patterns from the database and active filtering. Note that this does
         *     **NOT** remove the corresponding matches nor will it halt or restart synchronization.
         *     The server will continue filtering new blocks but, will that pattern removed.
         *
         */
        delete: operations["deletePattern"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/checkpoints": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Sample Checkpoints
         * @description Retrieve a **sample of** all checkpoints currently in the database, in descending `slot_no` order.
         *     This is useful to know where the synchronization is at. On restart, the synchronization will continue from the most recent
         *     checkpoints that is also valid on the network.
         *
         */
        get: operations["sampleCheckpoints"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/checkpoints/{slot_no}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Checkpoint By Slot
         * @description Retrieve a checkpoint by its (absolute) slot number. The query is flexible by default. Meaning that, if there's no checkpoint at the given slot, the server
         *     will for for the closest (i.e. most recent) slot that is **before** the provided slot number. This is particularly useful to find ancestors to known slots
         *     in order to use them for references on-chain.
         *
         */
        get: operations["getCheckpointBySlot"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/metadata/{slot_no}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Metadata By Slot
         * @description Retrieve all metadata data seen in a block at the given slot, possibly filtered by transaction id.
         *
         *     Metadata are ordered according to their respective transaction's order in the block.
         *
         */
        get: operations["getMetadataBySlot"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Health
         * @description Retrieve Kupo's application health status. Note that this call is cheap and does not halt the various concurrent tasks performed by the Kupo.
         *
         *     This endpoint has two possible content-types: `application/json` or `text/plain`. The latter returns health in a format suitable for [Prometheus](https://prometheus.io/docs/introduction/overview/). The server defaults to `application/json`, but you can control this behavior by passing a corresponding `Accept` header.
         *
         *     In addition, the server may return any of the following response codes:
         *     - 200: when healthy
         *     - 202: when connected to a chain producer but still syncing
         *     - 503: when disconnected from a chain producer
         *
         */
        get: operations["getHealth"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/metrics": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Metrics
         * @description Like [`/health`](#operation/getHealth), but always return `200 OK` as a status.
         *
         */
        get: operations["getMetrics"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
};
export type webhooks = Record<string, never>;
export type components = {
    schemas: {
        /** Shelley */
        Address_Shelley: string;
        /** Stake */
        Address_Stake: string;
        /** Bootstrap */
        Address_Bootstrap: string;
        /**
         * Credentials
         * @description ```
         *       ┏━━━━━━━━━━━━┓ ╭───╮ ┏━━━━━━━━━━━━┓
         *     ╾─┫ CREDENTIAL ┣─┤ / ├─┫ CREDENTIAL ┣─╼
         *       ┗━━━━━━━━━━━━┛ ╰───╯ ┗━━━━━━━━━━━━┛
         *     ```
         *
         *     One or two address credentials, separated by a `/`. The left-side identifies the payment
         *     part of the address, and the right-side identifies the delegation part. Both are optional
         *     an can be instead a wildcard (`*`).
         *
         *     Examples:
         *     - `addr_vk1x7da0l25j04my8sej5ntrgdn38wmshxhplxdfjskn07ufavsgtkqn5hljl/*`
         *     - `*\/script1cda3khwqv60360rp5m7akt50m6ttapacs8rqhn5w342z7r35m37`
         *     - `dca1e44765b9f80c8b18105e17de90d4a07e4d5a83de533e53fee32e0502d17e/*`
         *     - `*\/4fc6bb0c93780ad706425d9f7dc1d3c5e3ddbf29ba8486dce904a5fc`
         *     - `*\/*`
         *
         */
        Address_Credentials: string;
        /** @description A Cardano address, in any era. */
        Address: (string) | (string);
        /**
         * Address
         * @description A Cardano address or stake address.
         */
        AddressPattern: string | (string) | (string) | (string);
        /**
         * AssetId
         * @description ```
         *       ┏━━━━━━━━━━━┓ ╭───╮ ┏━━━━━━━━━━━━┓
         *     ╾─┫ POLICY_ID ┣─┤ . ├─┫ ASSET_NAME ┣─╼
         *       ┗━━━━━━━━━━━┛ ╰───╯ ┗━━━━━━━━━━━━┛
         *     ```
         *
         *     A policy id (base16-encoded) and an optional asset name (base16-encoded), dot-separated.
         *
         *     Examples:
         *     - `1220099e5e430475c219518179efc7e6c8289db028904834025d5b086.*`
         *     - `1220099e5e430475c219518179efc7e6c8289db028904834025d5b086.08661220099e`
         *
         */
        AssetIdPattern: string;
        BadRequest: {
            /** @description Some hint about what went wrong. */
            hint?: string;
        };
        /**
         * @description A serialized Plutus' Data (datum or redeemer).
         * @example d87980
         */
        BinaryData: string;
        /** Datum */
        Datum: {
            datum: components["schemas"]["BinaryData"];
        };
        /** @description A blake2b-256 hash digest of a Plutus' datum, if any. */
        DatumHash: string | null;
        /**
         * @description Categorize the type of datum in the output:
         *
         *     - `hash`: means that the output only contains a reference to the datum;
         *     - `inline`: means that the ouput originally contained a full inline datum.
         *
         *     In both cases however, Kupo returns only a `datum_hash`, and full datums
         *     can be retrieved via the [`GET /datums/{datum_hash}`](#tag/Datums/paths/~1datums~1{datum_hash}/get)
         *     endpoint.
         *
         *     This field is only present when `datum_hash` is not `null`.
         *
         * @enum {string}
         */
        DatumType: "hash" | "inline";
        Deleted: {
            /** @description Number of entities effectively deleted. */
            deleted: number;
        };
        ForcedRollback: {
            /** @description A mandatory point to rollback the synchronization to.
             *     Note that the synchronization will therefore begin starting from the point **immediately after** the provided point!
             *
             *     > <sup><strong>NOTE (1)</strong></sup> <br/>
             *     > If you need to query ancestors from any given known point, see [`GET /checkpoints/{slot_no}`](#operation/getCheckpointBySlot)
             *
             *     > <sup><strong>NOTE (2)</strong></sup> <br/>
             *     > The `header_hash` is **optional**! However if provided, Kupo will check that it rolls back exactly to the specified point by comparing header hashes.
             *     > If it's omitted, Kupo will rollback to the given slot number or, any closest ancestor if no point is found at the given slot.
             *      */
            rollback_to: {
                slot_no: components["schemas"]["SlotNo"];
                header_hash?: components["schemas"]["HeaderHash"];
            };
            /**
             * @description Specify the server behavior when rolling back out of the _safe
             *     zone_. As mentioned in the user manual, when running Kupo with
             *     `--prune-utxo` enabled, the server gets rid of spent UTxOs, but it
             *     only does so after a certain time. That time is exactly `129600`
             *     slots (or 36h on Mainnet/Testnet). This is because the core
             *     protocol cannot roll back further than this particular depth and it
             *     is the point after which it is 100% safe to remove data from the
             *     database.
             *
             *     However, this endpoint allows you to break this invariant and
             *     rollback to points that are even older in the past. As a
             *     consequence, while syncing, the index may be in a somewhat
             *     inconsistent state because some inputs spent at a later time may
             *     not have been recovered during the rollback. This may be surprising
             *     if you're expecting to see and query those transient inputs after
             *     rolling back.
             *
             *     By default, you won't be allowed to rollback beyond the safe zone.
             *     If, however, you know what you're doing, you're kindly asked to
             *     pass `unsafe_allow_beyond_safe_zone` as a token of acknowledgment.
             *     Passing `within_safe_zone` has no effects other than the default.
             *
             *     Note that, once synchronized again, the index will always be in the
             *     expected state and problems reflecting reality only occurs _while
             *     catching up_, after a long rollback.
             *
             * @default within_safe_zone
             * @enum {string}
             */
            limit: "unsafe_allow_beyond_safe_zone" | "within_safe_zone";
        };
        /**
         * @description A blake2b-256 hash digest of a block header.
         * @example 9d09...31bf
         */
        HeaderHash: string;
        /**
         * @description The index of the input within the transaction carrying it.
         * @example 1
         */
        InputIndex: number;
        Metadata: {
            /**
             * @description A blake2b-256 hash digest of the raw serialized data
             * @example cd6a5d31bf9d309706b92ad83402e682fdab9fc889b1b63565ee3de14e09dedf
             */
            hash: string;
            /** @description A [CBOR](https://www.rfc-editor.org/rfc/rfc8949.html)-encoded binary payload. */
            raw: string;
            /**
             * @description A high-level description of the raw data. The top-level object is an object where all keys are integers (possibly negative) and points to objects representing one of 5 primitives:
             *
             *     - int
             *     - string
             *     - bytes
             *     - list
             *     - map
             *
             *     This schema is meant to give a faithful representation of the underlying [CBOR](https://www.rfc-editor.org/rfc/rfc8949.html) encoding, which is slightly more expressive than pure JSON (e.g. keys of maps can be arbitrary CBOR objects).
             *
             *     This is why it is generally not possible to ensure a 1:1 conversion between low-level CBOR and JSON, and why this intermediate representation is necessary to safely represent **any** metadata object.
             *
             * @example {
             *       "16": {
             *         "map": [
             *           {
             *             "k": {
             *               "string": "numbers"
             *             },
             *             "v": {
             *               "list": [
             *                 {
             *                   "int": 1
             *                 },
             *                 {
             *                   "int": 2
             *                 },
             *                 {
             *                   "int": 4
             *                 },
             *                 {
             *                   "int": 8
             *                 }
             *               ]
             *             }
             *           },
             *           {
             *             "k": {
             *               "string": "alphabet"
             *             },
             *             "v": {
             *               "map": [
             *                 {
             *                   "k": {
             *                     "string": "A"
             *                   },
             *                   "v": {
             *                     "int": 65
             *                   }
             *                 },
             *                 {
             *                   "k": {
             *                     "string": "B"
             *                   },
             *                   "v": {
             *                     "int": 66
             *                   }
             *                 },
             *                 {
             *                   "k": {
             *                     "string": "C"
             *                   },
             *                   "v": {
             *                     "int": 67
             *                   }
             *                 }
             *               ]
             *             }
             *           }
             *         ]
             *       },
             *       "32": {
             *         "int": 42
             *       },
             *       "64": {
             *         "string": "some text"
             *       },
             *       "-8": {
             *         "bytes": "48656c6c6f2c2043617264616e6f21"
             *       }
             *     }
             */
            schema: {
                [key: string]: components["schemas"]["Metadatum"];
            };
        };
        Metadatum: components["schemas"]["Metadatum_Int"] | components["schemas"]["Metadatum_String"] | components["schemas"]["Metadatum_Bytes"] | components["schemas"]["Metadatum_List"] | components["schemas"]["Metadatum_Map"];
        /** int */
        Metadatum_Int: {
            /** @description An integer or arbitrary size.
             *
             *     Example:
             *
             *     ```json
             *     { "int": 42 }
             *     ```
             *      */
            int: number;
        };
        /** string */
        Metadatum_String: {
            /** @description A text string, which is at most 64 bytes.
             *
             *     Example:
             *
             *     ```json
             *     { "string": "kupo!" }
             *     ```
             *      */
            string: string;
        };
        /** bytes */
        Metadatum_Bytes: {
            /** @description A base16 byte string, which is at most 64 bytes
             *
             *     Example:
             *
             *     ```json
             *     { "bytes": "6b75706f21" }
             *     ```
             *      */
            bytes: string;
        };
        /** list */
        Metadatum_List: {
            /** @description A (possibly heterogeneous) list of metadatum
             *
             *     Example:
             *
             *     ```json
             *     {
             *       "list": [
             *         {
             *           "int": 14
             *         },
             *         {
             *           "list": [
             *             { "string": "kupo!" },
             *             { "bytes": "6b75706f21" }
             *           ]
             *         }
             *       ]
             *     }
             *     ```
             *      */
            list: components["schemas"]["Metadatum"][];
        };
        /** map */
        Metadatum_Map: {
            /** @description A list of key:value objects. Both keys and values can be any sort metadatum.
             *
             *     Example:
             *
             *     ```json
             *     {
             *       "map": [
             *         {
             *           "k": { "int": 14 },
             *           "v": {
             *             "list": [
             *               { "string": "kupo!" },
             *               { "bytes": "6b75706f21" }
             *             ]
             *           }
             *         }
             *       ]
             *     }
             *     ```
             *      */
            map: {
                k: components["schemas"]["Metadatum"];
                v: components["schemas"]["Metadatum"];
            }[];
        };
        /**
         * @description The index of the output within the transaction carrying it.
         * @example 2
         */
        OutputIndex: number;
        /**
         * OutputReference
         * @description ```
         *       ┏━━━━━━━━━━━━━━┓ ╭───╮ ┏━━━━━━━━━━━━━━━━┓
         *     ╾─┫ OUTPUT_INDEX ┣─┤ @ ├─┫ TRANSACTION_ID ┣─╼
         *       ┗━━━━━━━━━━━━━━┛ ╰───╯ ┗━━━━━━━━━━━━━━━━┛
         *     ```
         *
         *     An (optional) output index and transaction id (base16-encoded), separated by a `@`.
         *
         *     Examples:
         *       - `42@35d8340cd6a5d31bf9d09706b92adedf9b1b632e682fdab9fc8865ee3de14e09`
         *       - `*@35d8340cd6a5d31bf9d09706b92adedf9b1b632e682fdab9fc8865ee3de14e09`
         *
         */
        OutputReferencePattern: string;
        /** @description A matching pattern for addresses, assets or transactions.
         *
         *     See [Patterns](#section/Patterns) for more details.
         *      */
        Pattern: components["schemas"]["Wildcard"] | components["schemas"]["AddressPattern"] | components["schemas"]["AssetIdPattern"] | components["schemas"]["OutputReferencePattern"];
        /** Point */
        Point: {
            slot_no: components["schemas"]["SlotNo"];
            header_hash: components["schemas"]["HeaderHash"];
        };
        /** Script */
        Script: {
            /**
             * @description The type of script. `native` refers to pre-Alonzo scripts made of the native DSL to combine keys.
             * @enum {string}
             */
            language: "native" | "plutus:v1" | "plutus:v2" | "plutus:v3";
            /**
             * @description A serialized script (native or Plutus).
             * @example 4d01000033222220051200120011
             */
            script: string;
        };
        /** @description A blake2b-224 hash digest of a Native or Plutus script, if any. */
        ScriptHash: string | null;
        /**
         * @description An absolut slot number.
         * @example 51540727
         */
        SlotNo: number;
        /** SpentAt */
        SpentAt: {
            slot_no: components["schemas"]["SlotNo"];
            header_hash: components["schemas"]["HeaderHash"];
            transaction_id: components["schemas"]["TransactionId"] | null;
            input_index: components["schemas"]["InputIndex"] | null;
            redeemer: components["schemas"]["BinaryData"] | null;
        };
        /**
         * @description A blake2b-256 hash digest of a transaction body.
         * @example 35d8...4e09
         */
        TransactionId: string;
        /**
         * @description The index of the transaction within the block including it.
         * @example 14
         */
        TransactionIndex: number;
        /** @description A (multi-asset) value of a transaction's output. */
        Value: {
            /**
             * @description A quantity of Lovelace.
             * @example 42
             */
            coins: number;
            /**
             * @description A _key:value_ map of asset identifier → quantity.
             * @example {
             *       "1220099e5e430475c219518179efc7e6c8289db028904834025d5b086": 231,
             *       "289db028904834025d5b085d5b08661220099e5e430475c2195181796.08661220099e": 1
             *     }
             */
            assets?: {
                [key: string]: number;
            };
        };
        /**
         * Wildcard
         * @enum {string}
         */
        Wildcard: "*";
        Match: {
            transaction_index: components["schemas"]["TransactionIndex"];
            transaction_id: components["schemas"]["TransactionId"];
            output_index: components["schemas"]["OutputIndex"];
            address: components["schemas"]["Address"];
            value: components["schemas"]["Value"];
            datum_hash: components["schemas"]["DatumHash"];
            /** @description The resolved datum, if available. The field is only and always present (yet may be `null`) if `?resolve_hashes` was set. */
            datum?: string | null;
            datum_type?: components["schemas"]["DatumType"];
            script_hash: components["schemas"]["ScriptHash"];
            /** @description The resolved script, if available. The field is only and always present (yet may be `null`) if `?resolve_hashes` was set. */
            script?: components["schemas"]["Script"] | null;
            /**
             * Point
             * @description Block reference at which this transaction was included in the ledger.
             */
            created_at: {
                slot_no: components["schemas"]["SlotNo"];
                header_hash: components["schemas"]["HeaderHash"];
            };
            /** @description Block reference at which this transaction input was spent, if any. */
            spent_at: components["schemas"]["SpentAt"] | null;
        };
        /** @description An overview of the server & connection status. Note that, when `most_recent_checkpoint` and `most_recent_node_tip` are equal, the index is fully synchronized. */
        Health: {
            /**
             * @description Condition of the connection with the underlying node.
             * @enum {string}
             */
            connection_status: "connected" | "disconnected";
            most_recent_checkpoint: number | null;
            most_recent_node_tip: number | null;
            seconds_since_last_block: number | null;
            network_synchronization: number | null;
            /** @description A summary of hand-picked configuration parameters. */
            configuration: {
                /**
                 * @description Behaviour surrounding the database query indexes.
                 * @enum {string}
                 */
                indexes: "deferred" | "installed";
            };
            /** @description Current software version. */
            version: string;
        };
        /** @description A key-value export compatible with Prometheus.
         *
         *     - `connected` and `disconnected` (from `connection_status`) are encoded as `1.0` and `0.0` respectively.
         *     - `installed` and `deferred` (from `configuration.indexes`) are encoded as `1.0` and `0.0` respectively.
         *     - `version` is not present in the Prometheus metrics.
         *      */
        HealthPrometheus: string;
    };
    responses: {
        /** @description Not Modified
         *
         *     Returned when a `If-None-Match` request header matches the current `ETag` for the response.
         *     This is meant to provide efficient caching and polling. The `ETag` corresponds to the most
         *     recent block header hash processed by Kupo.
         *      */
        304: {
            headers: {
                "Content-Type"?: "application/json;charset=utf-8";
                /** @description Kupo's most recent indexed block's slot number. This allows to know which slot a query is accurate of.
                 *      */
                "X-Most-Recent-Checkpoint"?: number;
                /** @description A cache value generated by the server to indicate whether a response has changed or not. The `ETag` always corresponds to the block header hash of the most recent indexed block.
                 *     This can be used in combination with [`If-None-Match`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#etagif-none-match) to provide some efficient client-side caching.
                 *      */
                ETag?: string;
                [name: string]: unknown;
            };
            content?: never;
        };
    };
    parameters: {
        /** @description Filters results to only those containing assets of a specific asset id. This parameter can't
         *     be used alone and must be provided alongside a `policy_id`.
         *      */
        "asset-name": string;
        /** @description Fetch only results created after (inclusive) some point.
         *
         *     > <sup><strong>NOTE</strong></sup> <br/>
         *     >
         *     > This can be combined with an upper bound (e.g. `{created, spent}_before`)
         *     > but cannot be combined with another lower bound.
         *      */
        "created-after": number | string;
        /** @description Fetch only results created before (inclusive) some point.
         *
         *     > <sup><strong>NOTE</strong></sup> <br/>
         *     >
         *     > This can be combined with a lower bound (e.g. `{created, spent}_after`)
         *     > but cannot be combined with another upper bound.
         *      */
        "created-before": number | string;
        /** @description A datum blake2b-256 hash digest. */
        "datum-hash": string;
        order: "most_recent_first" | "oldest_first";
        "output-index": number;
        /** @description A matching pattern on addresses, assets or transactions.
         *
         *     See [Patterns](#section/Patterns) for more details.
         *      */
        pattern: components["schemas"]["Wildcard"] | components["schemas"]["AddressPattern"] | components["schemas"]["AssetIdPattern"] | components["schemas"]["OutputReferencePattern"];
        /** @description Filters results to only those containing assets of a specific policy id.
         *     Useful when combined with a pattern as path-parameter.
         *
         *     > <sup><strong>WARNING</strong></sup> <br/>
         *     >
         *     > Query filters are slower than path-parameters. If you only need to match for a
         *     > specific policy id, use an explicit [Pattern](#section/Patterns) as _path-parameter_ instead.
         *      */
        "policy-id": string;
        /** @description A query flag (i.e. `?resolve_hashes`) to resolve hash references and include `datum` and `script` when available.
         *      */
        "resolve-hashes": string;
        /** @description A script blake2b-224 hash digest of a script. */
        "script-hash": string;
        "slot-no": number;
        /** @description A query flag (i.e. `?spent`) to filter matches by status, to get only 'spent' matches.  Note that, when running kupo with `--prune-utxo`, this will always return an empty list of results.
         *      */
        spent: string;
        /** @description Fetch only results spent after (inclusive) some point.
         *
         *     > <sup><strong>NOTE</strong></sup> <br/>
         *     >
         *     > This can be combined with an upper bound (e.g. `{created, spent}_before`)
         *     > but cannot be combined with another lower bound.
         *      */
        "spent-after": number | string;
        /** @description Fetch only results spent before (inclusive) some point.
         *
         *     > <sup><strong>NOTE</strong></sup> <br/>
         *     >
         *     > This can be combined with a lower bound (e.g. `{created, spent}_after`)
         *     > but cannot be combined with another upper bound.
         *      */
        "spent-before": number | string;
        /** @description A query flag (i.e. `?strict`) to only look for checkpoints that strictly match the provided slot. The behavior otherwise is to look for the largest nearest slot smaller or equal to the one provided.
         *      */
        strict: string;
        /** @description Filters results by transaction id to retrieve items originating from that transaction only.
         *     Useful when combined with a pattern as path-parameter.
         *
         *     > <sup><strong>WARNING</strong></sup> <br/>
         *     >
         *     > Query filters are slower than path-parameters. If you only need to match for a
         *     > specific transaction id, use an explicit [Pattern](#section/Patterns) as _path-parameter_ instead.
         *      */
        "transaction-id": components["schemas"]["TransactionId"];
        /** @description A query flag (i.e. `?unspent`) filter matches by status, to get only 'unspent' matches.
         *      */
        unspent: string;
    };
    requestBodies: never;
    headers: {
        "Content-Type": "application/json;charset=utf-8";
        /** @description Kupo's most recent indexed block's slot number. This allows to know which slot a query is accurate of.
         *      */
        "X-Most-Recent-Checkpoint": number;
        /** @description A cache value generated by the server to indicate whether a response has changed or not. The `ETag` always corresponds to the block header hash of the most recent indexed block.
         *     This can be used in combination with [`If-None-Match`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#etagif-none-match) to provide some efficient client-side caching.
         *      */
        ETag: string;
    };
    pathItems: never;
};
export type $defs = Record<string, never>;
export interface operations {
    getAllMatches: {
        parameters: {
            query?: {
                /** @description A query flag (i.e. `?resolve_hashes`) to resolve hash references and include `datum` and `script` when available.
                 *      */
                resolve_hashes?: components["parameters"]["resolve-hashes"];
                /** @description A query flag (i.e. `?spent`) to filter matches by status, to get only 'spent' matches.  Note that, when running kupo with `--prune-utxo`, this will always return an empty list of results.
                 *      */
                spent?: components["parameters"]["spent"];
                /** @description A query flag (i.e. `?unspent`) filter matches by status, to get only 'unspent' matches.
                 *      */
                unspent?: components["parameters"]["unspent"];
                order?: components["parameters"]["order"];
                /** @description Fetch only results created after (inclusive) some point.
                 *
                 *     > <sup><strong>NOTE</strong></sup> <br/>
                 *     >
                 *     > This can be combined with an upper bound (e.g. `{created, spent}_before`)
                 *     > but cannot be combined with another lower bound.
                 *      */
                created_after?: components["parameters"]["created-after"];
                /** @description Fetch only results spent after (inclusive) some point.
                 *
                 *     > <sup><strong>NOTE</strong></sup> <br/>
                 *     >
                 *     > This can be combined with an upper bound (e.g. `{created, spent}_before`)
                 *     > but cannot be combined with another lower bound.
                 *      */
                spent_after?: components["parameters"]["spent-after"];
                /** @description Fetch only results created before (inclusive) some point.
                 *
                 *     > <sup><strong>NOTE</strong></sup> <br/>
                 *     >
                 *     > This can be combined with a lower bound (e.g. `{created, spent}_after`)
                 *     > but cannot be combined with another upper bound.
                 *      */
                created_before?: components["parameters"]["created-before"];
                /** @description Fetch only results spent before (inclusive) some point.
                 *
                 *     > <sup><strong>NOTE</strong></sup> <br/>
                 *     >
                 *     > This can be combined with a lower bound (e.g. `{created, spent}_after`)
                 *     > but cannot be combined with another upper bound.
                 *      */
                spent_before?: components["parameters"]["spent-before"];
                /** @description Filters results to only those containing assets of a specific policy id.
                 *     Useful when combined with a pattern as path-parameter.
                 *
                 *     > <sup><strong>WARNING</strong></sup> <br/>
                 *     >
                 *     > Query filters are slower than path-parameters. If you only need to match for a
                 *     > specific policy id, use an explicit [Pattern](#section/Patterns) as _path-parameter_ instead.
                 *      */
                policy_id?: components["parameters"]["policy-id"];
                /** @description Filters results to only those containing assets of a specific asset id. This parameter can't
                 *     be used alone and must be provided alongside a `policy_id`.
                 *      */
                asset_name?: components["parameters"]["asset-name"];
                /** @description Filters results by transaction id to retrieve items originating from that transaction only.
                 *     Useful when combined with a pattern as path-parameter.
                 *
                 *     > <sup><strong>WARNING</strong></sup> <br/>
                 *     >
                 *     > Query filters are slower than path-parameters. If you only need to match for a
                 *     > specific transaction id, use an explicit [Pattern](#section/Patterns) as _path-parameter_ instead.
                 *      */
                transaction_id?: components["parameters"]["transaction-id"];
                output_index?: components["parameters"]["output-index"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    "Content-Type"?: "application/json;charset=utf-8";
                    /** @description Kupo's most recent indexed block's slot number. This allows to know which slot a query is accurate of.
                     *      */
                    "X-Most-Recent-Checkpoint"?: number;
                    /** @description A cache value generated by the server to indicate whether a response has changed or not. The `ETag` always corresponds to the block header hash of the most recent indexed block.
                     *     This can be used in combination with [`If-None-Match`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#etagif-none-match) to provide some efficient client-side caching.
                     *      */
                    ETag?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json;charset=utf-8": components["schemas"]["Match"][];
                };
            };
            304: components["responses"]["304"];
        };
    };
    getMatches: {
        parameters: {
            query?: {
                /** @description A query flag (i.e. `?resolve_hashes`) to resolve hash references and include `datum` and `script` when available.
                 *      */
                resolve_hashes?: components["parameters"]["resolve-hashes"];
                /** @description A query flag (i.e. `?spent`) to filter matches by status, to get only 'spent' matches.  Note that, when running kupo with `--prune-utxo`, this will always return an empty list of results.
                 *      */
                spent?: components["parameters"]["spent"];
                /** @description A query flag (i.e. `?unspent`) filter matches by status, to get only 'unspent' matches.
                 *      */
                unspent?: components["parameters"]["unspent"];
                order?: components["parameters"]["order"];
                /** @description Fetch only results created after (inclusive) some point.
                 *
                 *     > <sup><strong>NOTE</strong></sup> <br/>
                 *     >
                 *     > This can be combined with an upper bound (e.g. `{created, spent}_before`)
                 *     > but cannot be combined with another lower bound.
                 *      */
                created_after?: components["parameters"]["created-after"];
                /** @description Fetch only results spent after (inclusive) some point.
                 *
                 *     > <sup><strong>NOTE</strong></sup> <br/>
                 *     >
                 *     > This can be combined with an upper bound (e.g. `{created, spent}_before`)
                 *     > but cannot be combined with another lower bound.
                 *      */
                spent_after?: components["parameters"]["spent-after"];
                /** @description Fetch only results created before (inclusive) some point.
                 *
                 *     > <sup><strong>NOTE</strong></sup> <br/>
                 *     >
                 *     > This can be combined with a lower bound (e.g. `{created, spent}_after`)
                 *     > but cannot be combined with another upper bound.
                 *      */
                created_before?: components["parameters"]["created-before"];
                /** @description Fetch only results spent before (inclusive) some point.
                 *
                 *     > <sup><strong>NOTE</strong></sup> <br/>
                 *     >
                 *     > This can be combined with a lower bound (e.g. `{created, spent}_after`)
                 *     > but cannot be combined with another upper bound.
                 *      */
                spent_before?: components["parameters"]["spent-before"];
                /** @description Filters results to only those containing assets of a specific policy id.
                 *     Useful when combined with a pattern as path-parameter.
                 *
                 *     > <sup><strong>WARNING</strong></sup> <br/>
                 *     >
                 *     > Query filters are slower than path-parameters. If you only need to match for a
                 *     > specific policy id, use an explicit [Pattern](#section/Patterns) as _path-parameter_ instead.
                 *      */
                policy_id?: components["parameters"]["policy-id"];
                /** @description Filters results to only those containing assets of a specific asset id. This parameter can't
                 *     be used alone and must be provided alongside a `policy_id`.
                 *      */
                asset_name?: components["parameters"]["asset-name"];
                /** @description Filters results by transaction id to retrieve items originating from that transaction only.
                 *     Useful when combined with a pattern as path-parameter.
                 *
                 *     > <sup><strong>WARNING</strong></sup> <br/>
                 *     >
                 *     > Query filters are slower than path-parameters. If you only need to match for a
                 *     > specific transaction id, use an explicit [Pattern](#section/Patterns) as _path-parameter_ instead.
                 *      */
                transaction_id?: components["parameters"]["transaction-id"];
                output_index?: components["parameters"]["output-index"];
            };
            header?: never;
            path: {
                /** @description A matching pattern on addresses, assets or transactions.
                 *
                 *     See [Patterns](#section/Patterns) for more details.
                 *      */
                pattern: components["parameters"]["pattern"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    "Content-Type"?: "application/json;charset=utf-8";
                    /** @description Kupo's most recent indexed block's slot number. This allows to know which slot a query is accurate of.
                     *      */
                    "X-Most-Recent-Checkpoint"?: number;
                    /** @description A cache value generated by the server to indicate whether a response has changed or not. The `ETag` always corresponds to the block header hash of the most recent indexed block.
                     *     This can be used in combination with [`If-None-Match`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#etagif-none-match) to provide some efficient client-side caching.
                     *      */
                    ETag?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json;charset=utf-8": components["schemas"]["Match"][];
                };
            };
            304: components["responses"]["304"];
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json;charset=utf-8": components["schemas"]["BadRequest"];
                };
            };
        };
    };
    deleteMatches: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description A matching pattern on addresses, assets or transactions.
                 *
                 *     See [Patterns](#section/Patterns) for more details.
                 *      */
                pattern: components["parameters"]["pattern"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    "Content-Type"?: "application/json;charset=utf-8";
                    /** @description Kupo's most recent indexed block's slot number. This allows to know which slot a query is accurate of.
                     *      */
                    "X-Most-Recent-Checkpoint"?: number;
                    /** @description A cache value generated by the server to indicate whether a response has changed or not. The `ETag` always corresponds to the block header hash of the most recent indexed block.
                     *     This can be used in combination with [`If-None-Match`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#etagif-none-match) to provide some efficient client-side caching.
                     *      */
                    ETag?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json;charset=utf-8": components["schemas"]["Deleted"];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json;charset=utf-8": components["schemas"]["BadRequest"];
                };
            };
        };
    };
    getPatterns: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    "Content-Type"?: "application/json;charset=utf-8";
                    /** @description Kupo's most recent indexed block's slot number. This allows to know which slot a query is accurate of.
                     *      */
                    "X-Most-Recent-Checkpoint"?: number;
                    /** @description A cache value generated by the server to indicate whether a response has changed or not. The `ETag` always corresponds to the block header hash of the most recent indexed block.
                     *     This can be used in combination with [`If-None-Match`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#etagif-none-match) to provide some efficient client-side caching.
                     *      */
                    ETag?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json;charset=utf-8": components["schemas"]["Pattern"][];
                };
            };
        };
    };
    putPatterns: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json;charset=utf-8": {
                    /** @description A list of patterns on addresses, assets or transactions as described in [Patterns](#section/Patterns). */
                    patterns: components["schemas"]["Pattern"][];
                    rollback_to: components["schemas"]["ForcedRollback"]["rollback_to"];
                    limit?: components["schemas"]["ForcedRollback"]["limit"];
                };
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    "Content-Type": components["headers"]["Content-Type"];
                    [name: string]: unknown;
                };
                content: {
                    "application/json;charset=utf-8": components["schemas"]["Pattern"][];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json;charset=utf-8": components["schemas"]["BadRequest"];
                };
            };
        };
    };
    matchPattern: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description A matching pattern on addresses, assets or transactions.
                 *
                 *     See [Patterns](#section/Patterns) for more details.
                 *      */
                pattern: components["parameters"]["pattern"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json;charset=utf-8": components["schemas"]["Pattern"][];
                };
            };
        };
    };
    putPattern: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description A matching pattern on addresses, assets or transactions.
                 *
                 *     See [Patterns](#section/Patterns) for more details.
                 *      */
                pattern: components["parameters"]["pattern"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json;charset=utf-8": components["schemas"]["ForcedRollback"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json;charset=utf-8": components["schemas"]["Pattern"][];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json;charset=utf-8": components["schemas"]["BadRequest"];
                };
            };
        };
    };
    deletePattern: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description A matching pattern on addresses, assets or transactions.
                 *
                 *     See [Patterns](#section/Patterns) for more details.
                 *      */
                pattern: components["parameters"]["pattern"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json;charset=utf-8": components["schemas"]["Deleted"];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json;charset=utf-8": components["schemas"]["BadRequest"];
                };
            };
        };
    };
    sampleCheckpoints: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    "Content-Type"?: "application/json;charset=utf-8";
                    /** @description Kupo's most recent indexed block's slot number. This allows to know which slot a query is accurate of.
                     *      */
                    "X-Most-Recent-Checkpoint"?: number;
                    /** @description A cache value generated by the server to indicate whether a response has changed or not. The `ETag` always corresponds to the block header hash of the most recent indexed block.
                     *     This can be used in combination with [`If-None-Match`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#etagif-none-match) to provide some efficient client-side caching.
                     *      */
                    ETag?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json;charset=utf-8": components["schemas"]["Point"][];
                };
            };
            304: components["responses"]["304"];
        };
    };
    getCheckpointBySlot: {
        parameters: {
            query?: {
                /** @description A query flag (i.e. `?strict`) to only look for checkpoints that strictly match the provided slot. The behavior otherwise is to look for the largest nearest slot smaller or equal to the one provided.
                 *      */
                strict?: components["parameters"]["strict"];
            };
            header?: never;
            path: {
                slot_no: components["parameters"]["slot-no"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    "Content-Type"?: "application/json;charset=utf-8";
                    /** @description Kupo's most recent indexed block's slot number. This allows to know which slot a query is accurate of.
                     *      */
                    "X-Most-Recent-Checkpoint"?: number;
                    /** @description A cache value generated by the server to indicate whether a response has changed or not. The `ETag` always corresponds to the block header hash of the most recent indexed block.
                     *     This can be used in combination with [`If-None-Match`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#etagif-none-match) to provide some efficient client-side caching.
                     *      */
                    ETag?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json;charset=utf-8": components["schemas"]["Point"] | null;
                };
            };
            304: components["responses"]["304"];
        };
    };
    getMetadataBySlot: {
        parameters: {
            query?: {
                /** @description Filters results by transaction id to retrieve items originating from that transaction only.
                 *      */
                transaction_id?: components["schemas"]["TransactionId"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    "Content-Type"?: "application/json;charset=utf-8";
                    /** @description Kupo's most recent indexed block's slot number. This allows to know which slot a query is accurate of.
                     *      */
                    "X-Most-Recent-Checkpoint"?: number;
                    /** @description A cache value generated by the server to indicate whether a response has changed or not. The `ETag` always corresponds to the block header hash of the most recent indexed block.
                     *     This can be used in combination with [`If-None-Match`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#etagif-none-match) to provide some efficient client-side caching.
                     *      */
                    ETag?: string;
                    /**
                     * @description The block's header hash digest (`blake2b-256`) of the corresponding block at the provided slot. Clients are expected to control that this hash matches the one they expect, especially when fetching metadata from blocks in the unstable region (i.e. less than `k=2160` blocks from the network tip). Indeed, Cardano is a distributed system after all and data isn't guaranteed to be immediately immutable. Data present in very recent blocks may therefore be different between two successive requests.
                     *
                     * @example 9d09...31bf
                     */
                    "X-Block-Header-Hash"?: unknown;
                    [name: string]: unknown;
                };
                content: {
                    "application/json;charset=utf-8": components["schemas"]["Metadata"][];
                };
            };
            304: components["responses"]["304"];
        };
    };
    getHealth: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Healthy */
            200: {
                headers: {
                    "Content-Type"?: "application/json;charset=utf-8";
                    /** @description Kupo's most recent indexed block's slot number. This allows to know which slot a query is accurate of.
                     *      */
                    "X-Most-Recent-Checkpoint"?: number;
                    /** @description A cache value generated by the server to indicate whether a response has changed or not. The `ETag` always corresponds to the block header hash of the most recent indexed block.
                     *     This can be used in combination with [`If-None-Match`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#etagif-none-match) to provide some efficient client-side caching.
                     *      */
                    ETag?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json;charset=utf-8": components["schemas"]["Health"];
                    "text/plain;charset=utf-8": components["schemas"]["HealthPrometheus"];
                };
            };
            /** @description Syncing */
            202: {
                headers: {
                    "Content-Type"?: "application/json;charset=utf-8";
                    /** @description Kupo's most recent indexed block's slot number. This allows to know which slot a query is accurate of.
                     *      */
                    "X-Most-Recent-Checkpoint"?: number;
                    /** @description A cache value generated by the server to indicate whether a response has changed or not. The `ETag` always corresponds to the block header hash of the most recent indexed block.
                     *     This can be used in combination with [`If-None-Match`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#etagif-none-match) to provide some efficient client-side caching.
                     *      */
                    ETag?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json;charset=utf-8": components["schemas"]["Health"];
                    "text/plain;charset=utf-8": components["schemas"]["HealthPrometheus"];
                };
            };
            /** @description Unavailable */
            503: {
                headers: {
                    "Content-Type"?: "application/json;charset=utf-8";
                    /** @description Kupo's most recent indexed block's slot number. This allows to know which slot a query is accurate of.
                     *      */
                    "X-Most-Recent-Checkpoint"?: number;
                    /** @description A cache value generated by the server to indicate whether a response has changed or not. The `ETag` always corresponds to the block header hash of the most recent indexed block.
                     *     This can be used in combination with [`If-None-Match`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#etagif-none-match) to provide some efficient client-side caching.
                     *      */
                    ETag?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json;charset=utf-8": components["schemas"]["Health"];
                    "text/plain;charset=utf-8": components["schemas"]["HealthPrometheus"];
                };
            };
        };
    };
    getMetrics: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Metrics */
            200: {
                headers: {
                    "Content-Type"?: "application/json;charset=utf-8";
                    /** @description Kupo's most recent indexed block's slot number. This allows to know which slot a query is accurate of.
                     *      */
                    "X-Most-Recent-Checkpoint"?: number;
                    /** @description A cache value generated by the server to indicate whether a response has changed or not. The `ETag` always corresponds to the block header hash of the most recent indexed block.
                     *     This can be used in combination with [`If-None-Match`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#etagif-none-match) to provide some efficient client-side caching.
                     *      */
                    ETag?: string;
                    [name: string]: unknown;
                };
                content: {
                    "text/plain;charset=utf-8": components["schemas"]["HealthPrometheus"];
                    "application/json;charset=utf-8": components["schemas"]["Health"];
                };
            };
        };
    };
}
